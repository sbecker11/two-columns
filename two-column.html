<!DOCTYPE html>
<html>
  <head>
    <title>Equal-Width Columns</title>
    <style>
      body,
      html {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #container {
        display: flex;
        height: 100%;
      }

      #left-column {
        flex: 1;
        background-color: black;
        overflow-y: scroll;
        position: relative;
      }

      #right-column {
        flex: 1;
        background-color: darkgrey;
        position: relative;
      }

      #report {
        color: white;
        position: absolute;
        top: 10px;
        left: 10px;
        white-space: pre-line;
        font-family: monospace;
      }

      #canvas {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .red-div {
        width: 150px;
        height: 150px;
        margin: 20px auto;
        background-color: red;
        border: 1px solid white;
      }

    </style>
  </head>
  <body>
    <div id="container">
      <div id="left-column">
        <div id="canvas">
          <!-- 10 red divs will be dynamically added here -->
        </div>
      </div>
      <div id="right-column">
        <canvas id="canvas"></canvas>
        <pre id="report"></pre>
      </div>
    </div>

    <script>
      let NUM_DIVS = 100;
      let DIV_SIZE_MIN = 150;
      let DIV_SIZE_MAX = 150;
      let DIV_MARGIN_MAX = 20;
      let DIV_X_OFFSET_MAX = 50;
      let DIV_Y_OFFSET_MAX = 50;
      let DIV_VT_MARGIN = 20;
      let PARALLAX_EXAGGERATION_FACTOR = 1.0;
      let RANDZ_MIN = 1;
      let RANDZ_MAX = 8;

      // returns a string between 100% and 12.8%
      function getZbrightnessStr(randZ) {
        val = linearInterp(randZ, RANDZ_MIN, 1.0, RANDZ_MAX, 0.5);
        val = Math.round(val * 100) / 100;
        var perc = `${100 * val}%`;
        return `brightness(${perc})`;
      }

      function getZblurStr(randZ) {
        var blur = randZ/2;
        return `blur(${blur}px)`;
      }

      function getZscale(randZ) {
        return (5 * 1.0) / randZ;
      }

      function toFixedPoint(value, point) {
        if (value) {
          return value.toFixed(point);
        }
        return value;
      }

      /**
       * Summary. Returns the translate string used to transform
       * any div's x,y coordinates into canvas-relative coordinates.
       * this assortment of divs has only a fixed number of possible
       * randZ values so the results of this function are cashed for
       * speed of access.
       *
       * Description. (use period)
       * @param {float}  dh           the horizontal parallax offset value
       * @param {float}  dv           the vertical parallax offet value
       * @param {int}    randZ        the random Z depth assigned to every div
       *                              with an integer value between RANDZ_MIN and RANDZ_MAX
       * @param {float}  canvas_dx    the x value used to convert div.x to canvas-relative position
       * @param {float}  canvas_dy    the y value used to convert div.y canvas-relative position
       *
       * @return {str} Return a string with format "12.02px -156.79px"
       */
      function getZTranslateInfoStr(dh, dv, randZ, canvas_dx, canvas_dy) {

        zScale = getZscale(randZ);
        // console.log(`getZTranslateInfoStr: dh:${dh} dv:${dv} randZ:${randZ} dx:${canvas_dx} dy:${canvas_dy}`);

        // by definition, divs have zero mean hzCtrs so canvas translation is required
        dx = toFixedPoint(dh * zScale + canvas_dx, 2);
        dy = toFixedPoint(dv * zScale + canvas_dy, 2);
        zTranslateInfoStr = `${dx}px ${dy}px`;
        // console.log(`getZTranslateInfoStr: dx:${dx} dy:${dy} dh:${dh} dv:${dv} randZ:${randZ} canvas ${canvas_dx},${canvas_dy}`);

        return zTranslateInfoStr;
      }

      // Function to update the report element
      function report(message) {
        document.getElementById("report").innerHTML = message;
      }

      // Call report("started") before the left column is initialized
      report("started");

      // Function to generate a random integer between min and max (inclusive)
      function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      function getRandom(min, max) {
        return Math.random() * (max - min) + min;
      }

      // return the y value given x
      const linearInterp = (x, x1, y1, x2, y2) =>
        y1 + ((x - x1) * (y2 - y1)) / (x2 - x1);

      // Function to create each red div with additional properties
      function createRedDiv() {
        var redDiv = document.createElement("div");
        redDiv.className = "red-div";

        document.getElementById("canvas").appendChild(redDiv);

        var randZ = getRandomInt(RANDZ_MIN, RANDZ_MAX);
        redDiv.setAttribute("data-rand-z", randZ);

        redDiv.style.width = getRandom(DIV_SIZE_MIN,DIV_SIZE_MAX) + "px";
        redDiv.style.height = getRandom(DIV_SIZE_MIN,DIV_SIZE_MAX) + "px";

        var margin_hz = 0;
        var margin_vt = getRandom(-DIV_MARGIN_MAX,DIV_MARGIN_MAX);
        redDiv.style.margin = `${margin_hz}px ${margin_vt}px`;

        redDiv.style.zIndex = -randZ;
        redDiv.innerHTML = `zIndex:${-randZ}`;

        var brightnessStr = getZbrightnessStr(randZ);
        var blurStr = getZblurStr(randZ);

        filtersStrs = `${brightnessStr} ${blurStr}`;
        redDiv.style.filter = filtersStrs;
        
        return redDiv;
      }

      // Function to update the report element
      function updateReport() {
        var reportMessage = generateReportMessage();
        report(reportMessage);
      }

      // Function to generate the report message
      function generateReportMessage() {
        var redDivHzCtr = getFirstRedDivHzCtr();
        var canvasHzCtr = getCanvasHzCtr();
        var leftColumnHzCtr = getLeftColumnHzCtr();
        var windowHzCtr = getWindowHzCtr();
        var leftColumnScrollTop = getLeftColumnScrollTop();
        var leftColumnOffsetHeight = getLeftColumnOffsetHeight();
        var canvasScrollTop = getCanvasScrollTop();
        var canvasOffsetHeight = getCanvasOffsetHeight();

        var reportMessage =
          "Window event type: " +
          window.event.type +
          "\n" +
          "Red-Div Horizontal Center: " +
          redDivHzCtr +
          "\n" +
          "Canvas Horizontal Center: " +
          canvasHzCtr +
          "\n" +
          "Left Column Horizontal Center: " +
          leftColumnHzCtr +
          "\n" +
          "Window Horizontal Center: " +
          windowHzCtr +
          "\n" +
          "Left Column ScrollTop: " +
          leftColumnScrollTop +
          "\n" +
          "Left Column OffsetHeight: " +
          leftColumnOffsetHeight +
          "\n" +
          "Canvas ScrollTop: " +
          canvasScrollTop +
          "\n" +
          "Canvas OffsetHeight: " +
          canvasOffsetHeight + 
          "\n";
        return reportMessage;
      }

      // Function to handle window resize event
      function handleResize() {

        // resize the left-column and the canvas since they don't doit themselves?
        var windowWidth = window.innerWidth;
        var leftColumnWidth = windowWidth / 2;
        
        document.getElementById("left-column").style.width =
          leftColumnWidth + "px";
        document.getElementById("canvas").style.width = leftColumnWidth + "px";

        updateReport();
      }

      // Function to handle window load event
      function handleLoad() {
        updateReport();
      }

      // Function to handle left-column scroll event
      function handleLeftColumnScroll() {
        updateReport();
      }

      // Function to get the canvas-relative horizontal center (hz-ctr) of the first red div
      function getFirstRedDivHzCtr() {
        var redDiv = document.querySelector(".red-div");
        var canvas = document.getElementById("canvas");
        var redDivRect = redDiv.getBoundingClientRect();
        var canvasRect = canvas.getBoundingClientRect();
        var redDivHzCtr =
          redDivRect.left - canvasRect.left + redDivRect.width / 2;
        return redDivHzCtr;
      }

      // Function to get the horizontal center (hz-ctr) of the canvas
      function getCanvasHzCtr() {
        var canvas = document.getElementById("canvas");
        var canvasHzCtr = canvas.offsetWidth / 2;
        return canvasHzCtr;
      }

      // Function to get the horizontal center (hz-ctr) of the left column
      function getLeftColumnHzCtr() {
        var leftColumn = document.getElementById("left-column");
        var leftColumnHzCtr = leftColumn.offsetWidth / 2;
        return leftColumnHzCtr;
      }

      // Function to get the horizontal center (hz-ctr) of the window
      function getWindowHzCtr() {
        var windowHzCtr = window.innerWidth / 2;
        return windowHzCtr;
      }

      // Function to get the scrollTop of the left column
      function getLeftColumnScrollTop() {
        var leftColumn = document.getElementById("left-column");
        var scrollTop = leftColumn.scrollTop;
        return scrollTop;
      }

      // Function to get the offsetHeight of the left column
      function getLeftColumnOffsetHeight() {
        var leftColumn = document.getElementById("left-column");
        var offsetHeight = leftColumn.offsetHeight;
        return offsetHeight;
      }

      // Function to get the scrollTop of the canvas
      function getCanvasScrollTop() {
        var canvas = document.getElementById("canvas");
        var scrollTop = canvas.scrollTop;
        return scrollTop;
      }

      // Function to get the offsetHeight of the canvas
      function getCanvasOffsetHeight() {
        var canvas = document.getElementById("canvas");
        var offsetHeight = canvas.offsetHeight;
        return offsetHeight;
      }

      function applyMotionParallax(parallax_dh, parallax_dv) {

        // first cache zTranslateInfoStrs for all possible values of randZ
        var dh = parallax_dh * PARALLAX_EXAGGERATION_FACTOR;
        var dv = parallax_dv * PARALLAX_EXAGGERATION_FACTOR;
        var average_div_size_offset = (DIV_SIZE_MIN+DIV_SIZE_MAX)/2;
        console.log(`parallax: dh:${parallax_dh} dv:${parallax_dv}`);
        var canvas_dx = getCanvasHzCtr() - average_div_size_offset/2;
        var canvas_dy = 0;
        zTranslateInfoStrs = [];
        for (var randZ = RANDZ_MIN; randZ <= RANDZ_MAX; randZ++) {
          var zTranslateInfoStr = getZTranslateInfoStr(
            dh, dv, randZ, canvas_dx, canvas_dy );
          zInfoIdx = randZ - RANDZ_MIN;
          zTranslateInfoStrs[zInfoIdx] = zTranslateInfoStr;
          // console.log(`randZ:${randZ} zTranslateInfoStr:${zTranslateInfoStr}`);
        }

        // apply the cached zTranslateInfoStr
        var redDivs = canvas.getElementsByClassName("red-div");
        for (var i = 0; i < redDivs.length; i++) {
          var redDiv = redDivs[i];
          var randZ = parseInt(
            redDiv.attributes.getNamedItem("data-rand-z").value
          );
          var zInfoIdx = randZ - RANDZ_MIN;
          var zTranslateInfoStr = zTranslateInfoStrs[zInfoIdx];
          redDiv.style.translate = zTranslateInfoStr;
        }
      }

      // Function to handle mousemove event on the window
      function handleWindowMouseMove(event) {

        var window = document.getElementById("container");
        var windowRect = window.getBoundingClientRect();
        var mouseX = event.clientX - windowRect.left;
        var mouseY = event.clientY - windowRect.top;

        centerDivX = windowRect.width / 2;
        centerDivY = windowRect.height / 2;

        var parallax_dh = mouseX - centerDivX;
        var parallax_dv = mouseY - centerDivY;

        applyMotionParallax(parallax_dh, parallax_dv);
      }

      // Attach event listeners
      window.addEventListener("resize", handleResize);
      window.addEventListener("load", handleLoad);
      window.addEventListener("mousemove", handleWindowMouseMove)
      document
        .getElementById("left-column")
        .addEventListener("scroll", handleLeftColumnScroll);

      var canvas = document.getElementById("canvas");

      // Generate 10 red divs with additional properties
      for (var i = 0; i < NUM_DIVS; i++) {
        var redDiv = createRedDiv();
        canvas.appendChild(redDiv);
      }
    </script>
  </body>
</html>
